{"org": "google", "repo": "gson", "number": 1014, "state": "closed", "title": "Fix JsonReader.peek() to handle malformed JSON gracefully", "body": "This PR fixes an issue where JsonReader.peek() would throw an exception when encountering malformed JSON instead of returning the appropriate token.", "base": {"label": "google:main", "ref": "main", "sha": "a1b2c3d4e5f6"}, "resolved_issues": [{"number": 1013, "title": "JsonReader.peek() throws exception on malformed JSON", "body": "When parsing malformed JSON, JsonReader.peek() should return an appropriate token instead of throwing an exception."}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 1234567..abcdefg 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -100,6 +100,10 @@ public JsonToken peek() throws IOException {\n     if (token != null) {\n       return token;\n     }\n+    // Handle malformed JSON gracefully\n+    if (pos >= limit && !fillBuffer(1)) {\n+      return JsonToken.END_DOCUMENT;\n+    }\n     return doPeek();\n   }", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\nindex 7890123..fedcba9 100644\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n@@ -500,6 +500,15 @@ public void testPeekOnValidJson() throws IOException {\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n+  public void testPeekOnMalformedJson() throws IOException {\n+    String json = \"{\\\"key\\\": \\\"value\\\"\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginObject();\n+    reader.nextName();\n+    reader.nextString();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n   public void testNextOnEmptyDocument() throws IOException {\n     JsonReader reader = new JsonReader(new StringReader(\"\"));\n     try {", "instance_id": "google__gson-1014"}
{"org": "apache", "repo": "commons-lang", "number": 2050, "state": "closed", "title": "Add null-safe string comparison utility", "body": "This PR adds a utility method for null-safe string comparison that handles null values gracefully.", "base": {"label": "apache:master", "ref": "master", "sha": "f1e2d3c4b5a6"}, "resolved_issues": [{"number": 2049, "title": "Need null-safe string comparison utility", "body": "StringUtils should provide a method to compare strings that handles null values without throwing NPE."}], "fix_patch": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 2345678..bcdefgh 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -1000,6 +1000,20 @@ public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n         return cs1.equals(cs2);\n     }\n \n+    /**\n+     * Compares two strings null-safely.\n+     * @param str1 the first string\n+     * @param str2 the second string\n+     * @return comparison result\n+     */\n+    public static int compareNullSafe(final String str1, final String str2) {\n+        if (str1 == null && str2 == null) return 0;\n+        if (str1 == null) return -1;\n+        if (str2 == null) return 1;\n+        return str1.compareTo(str2);\n+    }\n+\n     /**\n      * <p>Compares two CharSequences, returning {@code true} if they represent", "test_patch": "diff --git a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\nindex 3456789..cdefghi 100644\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n@@ -2000,6 +2000,18 @@ public void testEquals() {\n         assertFalse(StringUtils.equals(\"abc\", \"ABC\"));\n     }\n \n+    @Test\n+    public void testCompareNullSafe() {\n+        assertEquals(0, StringUtils.compareNullSafe(null, null));\n+        assertEquals(-1, StringUtils.compareNullSafe(null, \"abc\"));\n+        assertEquals(1, StringUtils.compareNullSafe(\"abc\", null));\n+        assertEquals(0, StringUtils.compareNullSafe(\"abc\", \"abc\"));\n+        assertTrue(StringUtils.compareNullSafe(\"abc\", \"def\") < 0);\n+        assertTrue(StringUtils.compareNullSafe(\"def\", \"abc\") > 0);\n+    }\n+\n     @Test\n     public void testEqualsOnCharSequences() {", "instance_id": "apache__commons-lang-2050"}
{"org": "spring-projects", "repo": "spring-framework", "number": 5678, "state": "closed", "title": "Improve error handling in @Async methods", "body": "This PR improves error handling for methods annotated with @Async by providing better exception propagation.", "base": {"label": "spring-projects:main", "ref": "main", "sha": "g6h7i8j9k0l1"}, "resolved_issues": [{"number": 5677, "title": "Async method exceptions are swallowed", "body": "Exceptions thrown in @Async methods are not properly propagated to the caller."}], "fix_patch": "diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncExecutionInterceptor.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncExecutionInterceptor.java\nindex 4567890..defghij 100644\n--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncExecutionInterceptor.java\n+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncExecutionInterceptor.java\n@@ -150,6 +150,12 @@ protected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor,\n \t\t\tif (completableFuture != null) {\n \t\t\t\treturn completableFuture.whenComplete((result, ex) -> {\n \t\t\t\t\tif (ex != null) {\n+\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n+\t\t\t\t\t\t\tlogger.error(\"Async method execution failed\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (exceptionHandler != null) {\n+\t\t\t\t\t\t\texceptionHandler.handleUncaughtException(ex, method, params);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}", "test_patch": "diff --git a/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java\nindex 5678901..efghijk 100644\n--- a/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java\n+++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java\n@@ -200,6 +200,20 @@ public void asyncMethodWithException() {\n \t\tassertThat(future.isCompletedExceptionally()).isTrue();\n \t}\n \n+\t@Test\n+\tpublic void asyncMethodExceptionHandling() throws Exception {\n+\t\tAsyncService service = context.getBean(AsyncService.class);\n+\t\tCompletableFuture<String> future = service.methodWithException();\n+\t\t\n+\t\ttry {\n+\t\t\tfuture.get(1, TimeUnit.SECONDS);\n+\t\t\tfail(\"Expected exception\");\n+\t\t} catch (ExecutionException ex) {\n+\t\t\tassertThat(ex.getCause()).isInstanceOf(RuntimeException.class);\n+\t\t\tassertThat(ex.getCause().getMessage()).isEqualTo(\"Async method failed\");\n+\t\t}\n+\t}\n+\n \tstatic class AsyncService {", "instance_id": "spring-projects__spring-framework-5678"}